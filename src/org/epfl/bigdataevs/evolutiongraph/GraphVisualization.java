package org.epfl.bigdataevs.evolutiongraph;

import org.apache.spark.api.java.JavaRDD;
import org.apache.spark.api.java.function.FlatMapFunction;
import org.apache.spark.api.java.function.Function;
import org.apache.spark.api.java.function.PairFlatMapFunction;
import org.apache.spark.api.java.function.PairFunction;
import org.epfl.bigdataevs.em.Theme;
import org.epfl.bigdataevs.eminput.TimePeriod;

import scala.Tuple2;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.TreeMap;

public class GraphVisualization {
  
  /**
   * Generate a .dot file ready to be generated with "dot" from graphviz with the given nodes and transitions
   * @param filename The filename of the output file
   * @param nodes The list of nodes
   * @param transitions The list of transitions between nodes 
   */
  private static void generateGraphFromString(String filename, List<Tuple2<Date,Iterable<String>>> nodes, List<Tuple2<String,String>> transitions){
    PrintWriter writer = null;

    try {
      writer = new PrintWriter(filename);
    } catch (FileNotFoundException e){
      System.out.println("Couldn't create file");
      return;
    }
    
    writer.println("digraph EvolutionGraph {\n\tranksep=.75; size = \"7.5,7.5\";\n\t{");
    writer.println("\t\tnode [shape=plaintext, fontsize=16];");
    
    /* Write dates */
    SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");
    writer.println("\t\t\"start\" ->");
    for(Tuple2<Date, Iterable<String>> node : nodes){
      Date date = node._1();
      writer.println("\t\t\""+format.format(date)+"\" ->");
    }
    writer.println("\t\t\"End\";");

    writer.println("\t}\n\t{\n\t\tnode [shape=box];");     
    
    /* Write themes */
    for(Tuple2<Date, Iterable<String>> node : nodes){
      Date date = node._1();
      Iterable<String> themes = node._2();
      
      writer.print("\t\t{ rank = same; ");
      writer.print("\"" + format.format(date) + "\";");
      
      for(String theme : themes){
        writer.print(" \""+theme+"\";");
      }
      
      writer.println("}");
    }
    
    /* Write transitions */
    for(Tuple2<String,String> transition : transitions){
      String th1 = transition._1();
      String th2 = transition._2();
      
      writer.println("\t\t\""+th1+"\" -> \""+th2+"\"");
    }
    
    writer.println("\t}\n}");
    
    writer.close();
  }
  
  
  /**
   * Generate a .dot file ready to be generated with "dot" from graphviz with the given themes
   * and the previously generated evolutionGraph within a particular time period
   * @param filename The filename of the output file
   * @param timePeriod The time period in which we want to generate the graph
   * @param themesRdd The list of themes
   * @param transitionGraph the transition graph generated by the KLDivergence class
   */
  public static void generateGraphFromRdd(String filename, TimePeriod timePeriod, JavaRDD<Theme> themesRdd, JavaRDD<EvolutionaryTransition> transitionGraph){
    final TimePeriod tp = timePeriod;
    
    List<Tuple2<Date, Iterable<String>>> nodes = themesRdd.flatMapToPair(new PairFlatMapFunction<Theme,Date,String>(){
      @Override
      public Iterable<Tuple2<Date, String>> call(Theme theme) throws Exception {
        ArrayList list = new ArrayList();
        if(tp.contains(theme.timePeriod))
          list.add(new Tuple2(theme.timePeriod.from, theme.toString()));
        return list;
      }
    }).groupByKey().sortByKey().collect();
    
    
    List<Tuple2<String,String>> transitions = transitionGraph.flatMap(
      new FlatMapFunction<EvolutionaryTransition,Tuple2<String,String>>(){

        @Override
        public Iterable<Tuple2<String, String>> call(EvolutionaryTransition transition) throws Exception {
          ArrayList list = new ArrayList();
          if(tp.contains(transition.theme1.timePeriod) && tp.contains(transition.theme2.timePeriod)){
            transition.theme1.toString();
            transition.theme2.toString();
            list.add(new Tuple2(transition.theme1.toString(), transition.theme2.toString()));
          }
          return(list);
        }
      }
    ).collect();
    
    generateGraphFromString(filename, nodes, transitions);
  }
  
}
