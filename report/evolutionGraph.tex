\subsection{Evolution Graph}
\paragraph{}
In section \ref{sec:ThemeExtraction} we showed a method to extract themes from the set of articles over a given period of time. However we are interested in detecting events that can last for a long time. This is why we studied evolutionary transitions. In section \ref{sec:EvoGraInt} we present a measure of distance between extracted themes and to show how it can be interpreted to detect long lasting events, then in section \ref{sec:EvoGraImp}, we discuss our implementation in parallel using spark.

\subsubsection{Interest}
\label{sec:EvoGraInt}

\paragraph{}
The distance we consider is called the Kullback divergence :\[ D(Theme1 || Theme2) = \sum_{word} P(word|Theme1) log(\frac{P(word|Theme1)}{P(word|Theme2)})\]where $P(word|theme)$ is the probability of reading the word $word$ in an article if it deals with the theme $theme$. It is commonly used in information theory to compare communication channels [citation needed]. Here we use it to have a measure of the difference between the probability distributions of two themes. 

\paragraph{}
[discussion with total variation distance ?]

\paragraph{}
We consider that we have an evolutionary transition between two themes $T_1$ and $T_2$ when $T_2$ comes after $T_1$ and if the divergence is bellow a threshold that we can choose. This way, the graph of evolutionary transition will reflect how a given theme is carried out from one period of time to an other. We will then be able to see both the real length of an event in time and also if new elements appeared at some point. [example needed]

\subsubsection{Implementation}
\label{sec:EvoGraImp}
\paragraph{}
The implementation works like ...

\paragraph{}
We used smoothed probabilities as it is discussed in \cite{de2010grammatical} because ... 

\subsubsection{performance}
\paragraph{}
Even so we parallelize the work efficiently, the evolution graph algorithm does not fit the definition of scalable. Indeed, if we have twice as many periods of time and twice as many executors the running time does not stay the same. It will be in fact multiplied by two. This is due to the inherent quadratic complexity of the algorithm which requires to measure the distance for each pair of themes.

\paragraph{}
We could avoid this quadratic complexity by looking only at similarity between theme that are close to each other in time. However we thought this simplification would make us lose interesting links like for example [pertinent example needed]

\paragraph{}
Our parallel implementation performs well :
\newline
\begin{tabular}{llll}
Number of Theme & Number of pairs & Number of executors & Execution time \\
\~ 200 & \~ 20000 & 500 & \~ 10s \\
\~ 2000 & \~ 2000000 & 500 & \~ 7min34s \\
\end{tabular}
\newline
[performance measure to be completed soon]


\subsubsection{Displaying the results}
In order to get a graphical representation of the results, we have decided to use GraphViz to generate a graph. Using Spark and the previously generated evolution graph RDD, we have implemented a .dot file generator to build the graph on a particular time-span.
[Graph Exemple Required]
